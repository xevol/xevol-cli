diff --git a/xevol-cli/package.json b/xevol-cli/package.json
index 48779303c..5a6676384 100644
--- a/xevol-cli/package.json
+++ b/xevol-cli/package.json
@@ -1,6 +1,6 @@
 {
   "name": "xevol",
-  "version": "0.11.2",
+  "version": "0.11.3",
   "description": "Xevol is a tool to consume, remix, make, publish, and offer systems, products, and workflows.",
   "type": "module",
   "bin": {
diff --git a/xevol-cli/src/lib/cache.ts b/xevol-cli/src/lib/cache.ts
index 68396e65e..6ddb4f9d7 100644
--- a/xevol-cli/src/lib/cache.ts
+++ b/xevol-cli/src/lib/cache.ts
@@ -5,6 +5,17 @@ import os from "os";
 
 const CACHE_DIR = path.join(os.homedir(), ".xevol", "cache");
 
+// ── In-memory cache layer (max 50 entries) ──
+const MEM_CACHE_MAX = 50;
+const memCache = new Map<string, CacheEntry<unknown>>();
+
+function memCacheEvict(): void {
+  if (memCache.size > MEM_CACHE_MAX) {
+    const firstKey = memCache.keys().next().value;
+    if (firstKey !== undefined) memCache.delete(firstKey);
+  }
+}
+
 /** Default TTLs in milliseconds */
 export const TTL = {
   LIST: 5 * 60 * 1000,       // 5 minutes for lists
@@ -41,6 +52,18 @@ async function ensureCacheDir(): Promise<void> {
 
 /** Get cached data if it exists and hasn't expired */
 export async function getCached<T>(key: string): Promise<{ data: T; stale: boolean } | null> {
+  // Check in-memory cache first
+  const mem = memCache.get(key) as CacheEntry<T> | undefined;
+  if (mem) {
+    const age = Date.now() - mem.timestamp;
+    if (age > mem.ttl * 2) {
+      memCache.delete(key);
+    } else {
+      return { data: mem.data, stale: age > mem.ttl };
+    }
+  }
+
+  // Fall through to disk
   try {
     const raw = await fs.readFile(cacheFilePath(key), "utf8");
     const entry = JSON.parse(raw) as CacheEntry<T>;
@@ -50,6 +73,9 @@ export async function getCached<T>(key: string): Promise<{ data: T; stale: boole
       void fs.unlink(cacheFilePath(key)).catch(() => {});
       return null;
     }
+    // Populate memCache from disk hit
+    memCache.set(key, entry);
+    memCacheEvict();
     return {
       data: entry.data,
       stale: age > entry.ttl,
@@ -61,13 +87,17 @@ export async function getCached<T>(key: string): Promise<{ data: T; stale: boole
 
 /** Store data in cache */
 export async function setCache(key: string, data: unknown, ttl?: number): Promise<void> {
+  const entry: CacheEntry<unknown> = {
+    data,
+    timestamp: Date.now(),
+    ttl: ttl ?? TTL.LIST,
+  };
+  // Write to in-memory cache
+  memCache.set(key, entry);
+  memCacheEvict();
+  // Write to disk
   try {
     await ensureCacheDir();
-    const entry: CacheEntry<unknown> = {
-      data,
-      timestamp: Date.now(),
-      ttl: ttl ?? TTL.LIST,
-    };
     await fs.writeFile(cacheFilePath(key), JSON.stringify(entry), "utf8");
   } catch {
     // Silently fail — cache is best-effort
@@ -76,6 +106,7 @@ export async function setCache(key: string, data: unknown, ttl?: number): Promis
 
 /** Clear all cached data */
 export async function clearCache(): Promise<void> {
+  memCache.clear();
   try {
     const files = await fs.readdir(CACHE_DIR);
     await Promise.all(
diff --git a/xevol-cli/src/lib/config.ts b/xevol-cli/src/lib/config.ts
index 019f58548..a6b268c6b 100644
--- a/xevol-cli/src/lib/config.ts
+++ b/xevol-cli/src/lib/config.ts
@@ -24,14 +24,25 @@ export const DEFAULT_API_URL = "https://api.xevol.com";
 const CONFIG_DIR = path.join(os.homedir(), ".xevol");
 export const CONFIG_PATH = path.join(CONFIG_DIR, "config.json");
 
+// ── In-memory config cache ──
+let _configCache: XevolConfig | null = null;
+let _configCacheAt = 0;
+const CONFIG_TTL = 30_000;
+
 async function ensureConfigDir(): Promise<void> {
   await fs.mkdir(CONFIG_DIR, { recursive: true });
 }
 
 export async function readConfig(): Promise<XevolConfig | null> {
+  if (_configCache && Date.now() - _configCacheAt < CONFIG_TTL) {
+    return _configCache;
+  }
   try {
     const raw = await fs.readFile(CONFIG_PATH, "utf8");
-    return JSON.parse(raw) as XevolConfig;
+    const config = JSON.parse(raw) as XevolConfig;
+    _configCache = config;
+    _configCacheAt = Date.now();
+    return config;
   } catch (error) {
     if ((error as { code?: string }).code === "ENOENT") {
       return null;
@@ -49,6 +60,8 @@ export async function writeConfig(config: XevolConfig): Promise<void> {
   await ensureConfigDir();
   const payload = JSON.stringify(config, null, 2) + "\n";
   await fs.writeFile(CONFIG_PATH, payload, { encoding: "utf8", mode: 0o600 });
+  _configCache = config;
+  _configCacheAt = Date.now();
 }
 
 export async function updateConfig(update: Partial<XevolConfig>): Promise<XevolConfig> {
diff --git a/xevol-cli/src/tui/hooks/useApi.ts b/xevol-cli/src/tui/hooks/useApi.ts
index 1160393d8..dd25f04d0 100644
--- a/xevol-cli/src/tui/hooks/useApi.ts
+++ b/xevol-cli/src/tui/hooks/useApi.ts
@@ -1,4 +1,4 @@
-import { useCallback, useEffect, useRef, useState } from "react";
+import { useCallback, useEffect, useMemo, useRef, useState } from "react";
 import type { DependencyList } from "react";
 import { apiFetch, type ApiRequestOptions } from "../../lib/api";
 import { readConfig, resolveApiUrl, resolveToken } from "../../lib/config";
@@ -22,9 +22,10 @@ export function useApi<T>(
   const optionsRef = useRef<ApiRequestOptions>(options);
   const mountedRef = useRef(true);
 
+  const optionsKey = useMemo(() => JSON.stringify(options), [options]);
   useEffect(() => {
     optionsRef.current = options;
-  }, [options]);
+  }, [optionsKey]);
 
   useEffect(() => {
     mountedRef.current = true;
diff --git a/xevol-cli/src/tui/screens/AddUrl.tsx b/xevol-cli/src/tui/screens/AddUrl.tsx
index f0f64ecba..48e62f717 100644
--- a/xevol-cli/src/tui/screens/AddUrl.tsx
+++ b/xevol-cli/src/tui/screens/AddUrl.tsx
@@ -1,4 +1,4 @@
-import React, { useCallback, useEffect, useState } from "react";
+import React, { useCallback, useEffect, useMemo, useState } from "react";
 import { Box, Text, useInput } from "ink";
 import TextInput from "ink-text-input";
 import { Spinner } from "../components/Spinner";
@@ -9,7 +9,7 @@ import { readConfig, resolveApiUrl, resolveToken } from "../../lib/config";
 import { streamSSE, type SSEEvent } from "../../lib/sse";
 import { extractId, extractStatus, pickValue } from "../../lib/utils";
 import { wrapText } from "../utils/wrapText";
-import { renderMarkdownLines } from "../utils/renderMarkdown";
+import { parseMarkdownStructure, renderMarkdownWindow } from "../utils/renderMarkdown";
 import { copyToClipboard } from "../utils/clipboard";
 import { useLayout } from "../context/LayoutContext";
 import { useInputLock } from "../context/InputContext";
@@ -192,10 +192,13 @@ export function AddUrl({ onBack, terminal }: AddUrlProps): JSX.Element {
   }, [phase, setFooterHints]);
 
   const contentWidth = Math.max(20, terminal.columns - 4);
-  const contentLines = renderMarkdownLines(streamContent || " ", contentWidth);
+  const parsedLines = useMemo(
+    () => parseMarkdownStructure(streamContent || " ", contentWidth),
+    [streamContent, contentWidth],
+  );
   const reservedRows = 10;
   const contentHeight = Math.max(4, terminal.rows - reservedRows);
-  const maxOffset = Math.max(0, contentLines.length - contentHeight);
+  const maxOffset = Math.max(0, parsedLines.length - contentHeight);
 
   // Auto-scroll during streaming, unless user has scrolled up
   const userScrolledRef = React.useRef(false);
@@ -461,7 +464,7 @@ export function AddUrl({ onBack, terminal }: AddUrlProps): JSX.Element {
     }
   });
 
-  const visibleLines = contentLines.slice(scrollOffset, scrollOffset + contentHeight);
+  const visibleLines = renderMarkdownWindow(parsedLines, scrollOffset, contentHeight);
 
   return (
     <Box flexDirection="column" paddingX={1} paddingY={1}>
diff --git a/xevol-cli/src/tui/screens/Dashboard.tsx b/xevol-cli/src/tui/screens/Dashboard.tsx
index e4064501f..1d6310f87 100644
--- a/xevol-cli/src/tui/screens/Dashboard.tsx
+++ b/xevol-cli/src/tui/screens/Dashboard.tsx
@@ -11,10 +11,6 @@ import { useLayout } from "../context/LayoutContext";
 import { parseResponse } from "../../lib/parseResponse";
 import { TranscriptionListResponseSchema } from "../../lib/schemas";
 
-// Module-level cache so navigating away and back doesn't re-fetch
-let _cachedRecent: Record<string, unknown> | null = null;
-let _cachedHistory: HistoryEntry[] | null = null;
-
 interface DashboardProps {
   version: string;
   navigation: Pick<NavigationState, "push">;
@@ -63,13 +59,12 @@ export function Dashboard({ version, navigation }: DashboardProps): JSX.Element
   const [selectedIndex, setSelectedIndex] = useState(0);
 
   // Local history — instant, no API call
-  const [historyItems, setHistoryItems] = useState<HistoryEntry[]>(_cachedHistory ?? []);
-  const [historyLoaded, setHistoryLoaded] = useState(!!_cachedHistory);
+  const [historyItems, setHistoryItems] = useState<HistoryEntry[]>([]);
+  const [historyLoaded, setHistoryLoaded] = useState(false);
 
   useEffect(() => {
     void (async () => {
       const history = await getHistory();
-      _cachedHistory = history;
       setHistoryItems(history);
       setHistoryLoaded(true);
     })();
@@ -91,16 +86,11 @@ export function Dashboard({ version, navigation }: DashboardProps): JSX.Element
     [],
   );
 
-  // Validate + update cache when fresh data arrives
-  const validatedRecentData = rawRecentData ? parseResponse(TranscriptionListResponseSchema, rawRecentData, "dashboard-recent") : null;
-  const recentData = validatedRecentData ?? _cachedRecent;
-
-  useEffect(() => {
-    if (validatedRecentData) _cachedRecent = validatedRecentData;
-  }, [validatedRecentData]);
+  // Validate response
+  const recentData = rawRecentData ? parseResponse(TranscriptionListResponseSchema, rawRecentData, "dashboard-recent") : null;
 
-  // Suppress loading indicator when we have cached data (no flash on re-visit)
-  const recentLoading = rawRecentLoading && !_cachedRecent;
+  // Suppress loading indicator when we have data (useApi provides stale-while-revalidate)
+  const recentLoading = rawRecentLoading && !recentData;
 
   // Auto-refresh removed — users can press `r` to refresh
 
diff --git a/xevol-cli/src/tui/screens/SpikeViewer.tsx b/xevol-cli/src/tui/screens/SpikeViewer.tsx
index f804cc981..24d65f8e4 100644
--- a/xevol-cli/src/tui/screens/SpikeViewer.tsx
+++ b/xevol-cli/src/tui/screens/SpikeViewer.tsx
@@ -6,7 +6,7 @@ import { StatusBadge } from "../components/StatusBadge";
 import { colors } from "../theme";
 import { pickValue } from "../../lib/utils";
 import { wrapText } from "../utils/wrapText";
-import { renderMarkdownLines } from "../utils/renderMarkdown";
+import { parseMarkdownStructure, renderMarkdownWindow } from "../utils/renderMarkdown";
 import { readConfig, resolveApiUrl, resolveToken } from "../../lib/config";
 import { streamSSE, type SSEEvent } from "../../lib/sse";
 import { useLayout } from "../context/LayoutContext";
@@ -218,14 +218,14 @@ export function SpikeViewer({ id, onBack, terminal }: SpikeViewerProps): JSX.Ele
 
   const contentWidth = Math.max(20, terminal.columns - 4);
   const spikeContent = activeSpike ? (streamContent || getSpikeContent(activeSpike)) : "";
-  const contentLines = useMemo(
-    () => renderMarkdownLines(spikeContent || "No spike content available.", contentWidth),
+  const parsedLines = useMemo(
+    () => parseMarkdownStructure(spikeContent || "No spike content available.", contentWidth),
     [spikeContent, contentWidth],
   );
 
   const reservedRows = 7 + (streamError ? 1 : 0) + (streaming ? 1 : 0);
   const contentHeight = Math.max(4, terminal.rows - reservedRows);
-  const maxOffset = Math.max(0, contentLines.length - contentHeight);
+  const maxOffset = Math.max(0, parsedLines.length - contentHeight);
 
   const userScrolledRef = React.useRef(false);
   useEffect(() => {
@@ -294,7 +294,7 @@ export function SpikeViewer({ id, onBack, terminal }: SpikeViewerProps): JSX.Ele
     }
   });
 
-  const visibleLines = contentLines.slice(scrollOffset, scrollOffset + contentHeight);
+  const visibleLines = renderMarkdownWindow(parsedLines, scrollOffset, contentHeight);
 
   return (
     <Box flexDirection="column" paddingX={1} paddingY={1}>
diff --git a/xevol-cli/src/tui/screens/TranscriptionDetail.tsx b/xevol-cli/src/tui/screens/TranscriptionDetail.tsx
index b3317440e..9972e6838 100644
--- a/xevol-cli/src/tui/screens/TranscriptionDetail.tsx
+++ b/xevol-cli/src/tui/screens/TranscriptionDetail.tsx
@@ -11,7 +11,7 @@ import { pickValue } from "../../lib/utils";
 import { formatDuration } from "../../lib/output";
 import { openUrl } from "../utils/openUrl";
 import { wrapText } from "../utils/wrapText";
-import { renderMarkdownLines } from "../utils/renderMarkdown";
+import { parseMarkdownStructure, renderMarkdownWindow } from "../utils/renderMarkdown";
 import { buildMarkdownFromAnalysis } from "../utils/markdown";
 import { readConfig, resolveApiUrl, resolveToken } from "../../lib/config";
 import { addToHistory } from "../../lib/history";
@@ -241,27 +241,29 @@ export function TranscriptionDetail({
     "";
 
   const contentWidth = Math.max(20, terminal.columns - 4);
-  const transcriptLines = useMemo(
-    () => renderMarkdownLines(transcript || "No transcript content available.", contentWidth),
+
+  // Two-phase markdown: parse structure (cached), render only visible window
+  const transcriptParsed = useMemo(
+    () => parseMarkdownStructure(transcript || "No transcript content available.", contentWidth),
     [transcript, contentWidth],
   );
 
-  const spikeContentLines = useMemo(
-    () => renderMarkdownLines(spikeContent || "", contentWidth),
+  const spikeContentParsed = useMemo(
+    () => parseMarkdownStructure(spikeContent || "", contentWidth),
     [spikeContent, contentWidth],
   );
 
   const reservedRows = 12 + (notice ? 2 : 0);
   const contentHeight = Math.max(4, terminal.rows - reservedRows);
 
-  const currentContentLines =
+  const currentParsedLines =
     activeTab === "transcript"
-      ? transcriptLines
+      ? transcriptParsed
       : spikeContent !== null
-        ? spikeContentLines
+        ? spikeContentParsed
         : [];
 
-  const maxOffset = Math.max(0, currentContentLines.length - contentHeight);
+  const maxOffset = Math.max(0, currentParsedLines.length - contentHeight);
 
   useEffect(() => {
     setScrollOffset((prev) => Math.min(prev, maxOffset));
@@ -587,7 +589,7 @@ export function TranscriptionDetail({
     }
   });
 
-  const visibleLines = currentContentLines.slice(scrollOffset, scrollOffset + contentHeight);
+  const visibleLines = renderMarkdownWindow(currentParsedLines, scrollOffset, contentHeight);
 
   // Tab bar component
   const tabBar = (
diff --git a/xevol-cli/src/tui/screens/TranscriptionList.tsx b/xevol-cli/src/tui/screens/TranscriptionList.tsx
index dc9dab0a3..fc8406634 100644
--- a/xevol-cli/src/tui/screens/TranscriptionList.tsx
+++ b/xevol-cli/src/tui/screens/TranscriptionList.tsx
@@ -16,7 +16,7 @@ import { formatDurationCompact } from "../../lib/output";
 import { openUrl } from "../utils/openUrl";
 import { buildMarkdownFromAnalysis } from "../utils/markdown";
 import { formatTimeAgo } from "../utils/time";
-import { renderMarkdownLines } from "../utils/renderMarkdown";
+import { parseMarkdownStructure, renderMarkdownWindow } from "../utils/renderMarkdown";
 import { SplitLayout } from "../components/SplitLayout";
 import type { NavigationState } from "../hooks/useNavigation";
 import { useLayout } from "../context/LayoutContext";
@@ -116,6 +116,7 @@ export function TranscriptionList({
   const [previewLoading, setPreviewLoading] = useState(false);
   const previewCacheRef = useRef<Map<string, { title: string; summary: string; status: string }>>(new Map());
   const previewTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);
+  const previewAbortRef = useRef<AbortController | null>(null);
 
   useEffect(() => {
     if (!notice) return;
@@ -251,7 +252,7 @@ export function TranscriptionList({
   const selectedIdsSet = useMemo(() => new Set(selectedIds), [selectedIds]);
   const selectedCount = selectedIds.length;
 
-  // Debounced preview fetch for wide mode
+  // Debounced preview fetch for wide mode with AbortController
   useEffect(() => {
     if (!isWide || !selectedItem) {
       setPreviewData(null);
@@ -265,6 +266,11 @@ export function TranscriptionList({
       return;
     }
 
+    // Abort previous in-flight request
+    previewAbortRef.current?.abort();
+    const controller = new AbortController();
+    previewAbortRef.current = controller;
+
     setPreviewLoading(true);
     previewTimerRef.current = setTimeout(() => {
       void (async () => {
@@ -276,7 +282,9 @@ export function TranscriptionList({
           const rawResponse = (await apiFetch(`/v1/analysis/${selectedItem.id}`, {
             token,
             apiUrl,
+            signal: controller.signal,
           })) as Record<string, unknown>;
+          if (controller.signal.aborted) return;
           const response = parseResponse(AnalysisResponseSchema, rawResponse, "analysis-preview");
           const analysis = unwrapAnalysis(response);
           const preview = {
@@ -285,17 +293,23 @@ export function TranscriptionList({
             status: pickValueOrDash(analysis ?? {}, ["status", "state"]),
           };
           previewCacheRef.current.set(selectedItem.id, preview);
-          setPreviewData(preview);
-        } catch {
+          if (!controller.signal.aborted) {
+            setPreviewData(preview);
+          }
+        } catch (err) {
+          if ((err as Error).name === "AbortError") return;
           setPreviewData(null);
         } finally {
-          setPreviewLoading(false);
+          if (!controller.signal.aborted) {
+            setPreviewLoading(false);
+          }
         }
       })();
     }, 300);
 
     return () => {
       if (previewTimerRef.current) clearTimeout(previewTimerRef.current);
+      controller.abort();
     };
   }, [isWide, selectedItem?.id]);
 
@@ -742,7 +756,7 @@ export function TranscriptionList({
           </Box>
           {previewData.summary ? (
             <Box marginTop={1} flexDirection="column">
-              <Text>{renderMarkdownLines(previewData.summary, previewWidth).slice(0, Math.max(4, terminal.rows - 10)).join("\n")}</Text>
+              <Text>{renderMarkdownWindow(parseMarkdownStructure(previewData.summary, previewWidth), 0, Math.max(4, terminal.rows - 10)).join("\n")}</Text>
             </Box>
           ) : null}
         </Box>
diff --git a/xevol-cli/src/tui/utils/renderMarkdown.ts b/xevol-cli/src/tui/utils/renderMarkdown.ts
index 091010e5f..bab8ddd72 100644
--- a/xevol-cli/src/tui/utils/renderMarkdown.ts
+++ b/xevol-cli/src/tui/utils/renderMarkdown.ts
@@ -1,12 +1,54 @@
 import chalk from "chalk";
 
+/** Module-level ANSI stripping regex (#8) */
+const ANSI_RE = /\x1b\[[0-9;]*m/g;
+
 /**
- * Convert markdown text to styled terminal lines using ANSI codes.
- * Handles: headers, bold, italic, inline code, code blocks, blockquotes, bullet lists.
+ * Strip ANSI escape codes from a string.
  */
-export function renderMarkdownLines(markdown: string, width: number): string[] {
+function stripAnsi(text: string): string {
+  ANSI_RE.lastIndex = 0;
+  return text.replace(ANSI_RE, "");
+}
+
+// ── LRU cache for parsed markdown structure (max 10 entries) ──
+
+interface ParseCacheEntry {
+  lines: string[];
+}
+
+const parseCache = new Map<string, ParseCacheEntry>();
+const PARSE_CACHE_MAX = 10;
+
+function parseCacheKey(markdown: string, width: number): string {
+  // Simple hash: length + first/last 100 chars + width
+  const prefix = markdown.slice(0, 100);
+  const suffix = markdown.slice(-100);
+  return `${markdown.length}:${width}:${prefix}:${suffix}`;
+}
+
+function parseCacheSet(key: string, lines: string[]): void {
+  if (parseCache.size >= PARSE_CACHE_MAX) {
+    // Evict oldest (first key)
+    const firstKey = parseCache.keys().next().value;
+    if (firstKey !== undefined) parseCache.delete(firstKey);
+  }
+  parseCache.set(key, { lines });
+}
+
+// ── Phase 1: Parse markdown structure (plain text, no ANSI) ──
+
+/**
+ * Parse markdown into plain-text lines (no ANSI formatting).
+ * Cached by content+width hash.
+ */
+export function parseMarkdownStructure(markdown: string, width: number): string[] {
   if (!markdown || width <= 0) return [];
 
+  const key = parseCacheKey(markdown, width);
+  const cached = parseCache.get(key);
+  if (cached) return cached.lines;
+
   const lines: string[] = [];
   const rawLines = markdown.split(/\r?\n/);
   let inCodeBlock = false;
@@ -14,87 +56,165 @@ export function renderMarkdownLines(markdown: string, width: number): string[] {
   for (let i = 0; i < rawLines.length; i++) {
     const line = rawLines[i];
 
-    // Code block toggle
     if (line.trimStart().startsWith("```")) {
       inCodeBlock = !inCodeBlock;
-      if (inCodeBlock) {
-        lines.push(chalk.dim("─".repeat(Math.min(width, 60))));
-      } else {
-        lines.push(chalk.dim("─".repeat(Math.min(width, 60))));
-      }
+      lines.push("───CODEBLOCK_SEPARATOR───");
       continue;
     }
 
     if (inCodeBlock) {
-      // Code block content — dim styling
-      for (const wrapped of wrapPlain(line, width)) {
-        lines.push(chalk.dim(wrapped));
+      for (const wrapped of wrapPlainText(line, width)) {
+        lines.push(`───CODE───${wrapped}`);
       }
       continue;
     }
 
-    // Headers
     const headerMatch = line.match(/^(#{1,6})\s+(.*)/);
     if (headerMatch) {
       const level = headerMatch[1].length;
-      const text = applyInlineFormatting(headerMatch[2]);
+      const text = stripInlineMarkdown(headerMatch[2]);
       const prefix = level <= 2 ? "" : "  ";
-      for (const wrapped of wrapPlain(text, width - prefix.length)) {
-        lines.push(prefix + chalk.bold.blueBright(wrapped));
+      for (const wrapped of wrapPlainText(text, width - prefix.length)) {
+        lines.push(`───H${level}───${prefix}${wrapped}`);
       }
       if (level <= 2) lines.push("");
       continue;
     }
 
-    // Blockquote
     if (line.trimStart().startsWith("> ")) {
-      const content = applyInlineFormatting(line.replace(/^\s*>\s?/, ""));
-      for (const wrapped of wrapPlain(content, width - 4)) {
-        lines.push(chalk.dim("│ ") + chalk.italic(wrapped));
+      const content = stripInlineMarkdown(line.replace(/^\s*>\s?/, ""));
+      for (const wrapped of wrapPlainText(content, width - 4)) {
+        lines.push(`───QUOTE───${wrapped}`);
       }
       continue;
     }
 
-    // Bullet list
     const bulletMatch = line.match(/^(\s*)[*\-+]\s+(.*)/);
     if (bulletMatch) {
       const indent = Math.min(bulletMatch[1].length, 8);
-      const content = applyInlineFormatting(bulletMatch[2]);
+      const content = stripInlineMarkdown(bulletMatch[2]);
       const prefix = " ".repeat(indent) + "• ";
-      for (const wrapped of wrapPlain(content, width - prefix.length)) {
-        lines.push(prefix + wrapped);
+      for (const wrapped of wrapPlainText(content, width - prefix.length)) {
+        lines.push(`───BULLET${indent}───${prefix}${wrapped}`);
       }
       continue;
     }
 
-    // Numbered list
     const numMatch = line.match(/^(\s*)\d+[.)]\s+(.*)/);
     if (numMatch) {
       const indent = Math.min(numMatch[1].length, 8);
-      const content = applyInlineFormatting(numMatch[2]);
+      const content = stripInlineMarkdown(numMatch[2]);
       const prefix = " ".repeat(indent) + "  ";
-      for (const wrapped of wrapPlain(content, width - prefix.length)) {
-        lines.push(prefix + wrapped);
+      for (const wrapped of wrapPlainText(content, width - prefix.length)) {
+        lines.push(`───NUM${indent}───${prefix}${wrapped}`);
       }
       continue;
     }
 
-    // Empty line
     if (!line.trim()) {
       lines.push("");
       continue;
     }
 
-    // Regular paragraph with inline formatting
-    const formatted = applyInlineFormatting(line);
-    for (const wrapped of wrapPlain(formatted, width)) {
-      lines.push(wrapped);
+    const text = stripInlineMarkdown(line);
+    for (const wrapped of wrapPlainText(text, width)) {
+      lines.push(`───PARA───${wrapped}`);
     }
   }
 
+  parseCacheSet(key, lines);
   return lines;
 }
 
+// ── Phase 2: Render visible window with ANSI formatting ──
+
+/**
+ * Apply ANSI formatting to a slice of parsed lines.
+ * Only formats the visible window for performance.
+ */
+export function renderMarkdownWindow(parsedLines: string[], start: number, count: number): string[] {
+  const end = Math.min(start + count, parsedLines.length);
+  const result: string[] = [];
+
+  for (let i = start; i < end; i++) {
+    const line = parsedLines[i];
+    result.push(formatParsedLine(line));
+  }
+
+  return result;
+}
+
+function formatParsedLine(line: string): string {
+  if (line === "") return "";
+
+  if (line === "───CODEBLOCK_SEPARATOR───") {
+    return chalk.dim("─".repeat(60));
+  }
+
+  if (line.startsWith("───CODE───")) {
+    return chalk.dim(line.slice(10));
+  }
+
+  const headerMatch = line.match(/^───H(\d)───(.*)/);
+  if (headerMatch) {
+    return chalk.bold.blueBright(headerMatch[2]);
+  }
+
+  if (line.startsWith("───QUOTE───")) {
+    return chalk.dim("│ ") + chalk.italic(line.slice(11));
+  }
+
+  if (line.match(/^───BULLET\d───/)) {
+    const content = line.replace(/^───BULLET\d───/, "");
+    return applyInlineFormatting(content);
+  }
+
+  if (line.match(/^───NUM\d───/)) {
+    const content = line.replace(/^───NUM\d───/, "");
+    return applyInlineFormatting(content);
+  }
+
+  if (line.startsWith("───PARA───")) {
+    return applyInlineFormatting(line.slice(10));
+  }
+
+  return line;
+}
+
+// ── Legacy API (kept for compatibility, delegates to two-phase) ──
+
+/**
+ * Convert markdown text to styled terminal lines using ANSI codes.
+ * Now delegates to two-phase approach internally.
+ */
+export function renderMarkdownLines(markdown: string, width: number): string[] {
+  if (!markdown || width <= 0) return [];
+
+  const parsed = parseMarkdownStructure(markdown, width);
+  return renderMarkdownWindow(parsed, 0, parsed.length);
+}
+
+// ── Helpers ──
+
+/**
+ * Strip inline markdown formatting markers (for plain text phase).
+ */
+function stripInlineMarkdown(text: string): string {
+  let result = text;
+  // Inline code
+  result = result.replace(/`([^`]+)`/g, "`$1`");
+  // Bold+italic
+  result = result.replace(/\*{3}([^*]+)\*{3}/g, "$1");
+  result = result.replace(/_{3}([^_]+)_{3}/g, "$1");
+  // Bold
+  result = result.replace(/\*{2}([^*]+)\*{2}/g, "$1");
+  result = result.replace(/_{2}([^_]+)_{2}/g, "$1");
+  // Italic
+  result = result.replace(/(?<!\w)\*([^*]+)\*(?!\w)/g, "$1");
+  result = result.replace(/(?<!\w)_([^_]+)_(?!\w)/g, "$1");
+  return result;
+}
+
 /**
  * Apply inline markdown formatting: bold, italic, inline code.
  * Uses chalk for ANSI styling.
@@ -119,105 +239,26 @@ function applyInlineFormatting(text: string): string {
 }
 
 /**
- * Wrap a single line of text (which may contain ANSI codes) to fit within width.
- * This is a simple word-wrap that accounts for visible character width.
+ * Simple word-wrap on plain text (no ANSI codes).
  */
-function wrapPlain(text: string, width: number): string[] {
+function wrapPlainText(text: string, width: number): string[] {
   if (width <= 0) return [];
+  if (text.length <= width) return [text];
 
-  // Strip ANSI to measure visible length
-  const visible = stripAnsi(text);
-  if (visible.length <= width) return [text];
-
-  // For ANSI-styled text, do character-level wrapping on visible chars
-  // This is a simplified approach: split by words on visible text, then reconstruct
-  const words = visible.split(/(\s+)/);
+  const words = text.split(/(\s+)/);
   const lines: string[] = [];
-  let currentVisible = "";
+  let current = "";
 
   for (const word of words) {
     if (!word) continue;
-    if (currentVisible.length + word.length <= width) {
-      currentVisible += word;
+    if (current.length + word.length <= width) {
+      current += word;
     } else {
-      if (currentVisible.trim()) lines.push(currentVisible.trimEnd());
-      if (word.trim()) {
-        currentVisible = word;
-      } else {
-        currentVisible = "";
-      }
+      if (current.trim()) lines.push(current.trimEnd());
+      current = word.trim() ? word : "";
     }
   }
-  if (currentVisible.trim()) lines.push(currentVisible.trimEnd());
-
-  // If the text had ANSI codes but we've lost them in word splitting,
-  // re-apply the formatting to each line by re-processing from original
-  if (text !== visible && lines.length > 0) {
-    // Rebuild using the original styled text, splitting at same positions
-    return rebuildStyledLines(text, lines, width);
-  }
+  if (current.trim()) lines.push(current.trimEnd());
 
   return lines.length > 0 ? lines : [text];
 }
-
-/**
- * Rebuild styled lines from original ANSI text matching the plain-text line breaks.
- */
-function rebuildStyledLines(styledText: string, plainLines: string[], _width: number): string[] {
-  // Simple approach: for short texts, just return the original
-  // For longer ones, try to split at line boundaries
-  if (plainLines.length <= 1) return [styledText];
-
-  const result: string[] = [];
-  let remaining = styledText;
-  
-  for (let i = 0; i < plainLines.length; i++) {
-    const plainLine = plainLines[i];
-    // Find where this plain line ends in the styled text
-    let visibleCount = 0;
-    let styledIdx = 0;
-    const targetLen = plainLine.length;
-
-    while (styledIdx < remaining.length && visibleCount < targetLen) {
-      // Skip ANSI escape sequences
-      const ansiMatch = remaining.slice(styledIdx).match(/^\x1b\[[0-9;]*m/);
-      if (ansiMatch) {
-        styledIdx += ansiMatch[0].length;
-        continue;
-      }
-      visibleCount++;
-      styledIdx++;
-    }
-
-    // Skip trailing whitespace in styled text
-    while (styledIdx < remaining.length) {
-      const ansiMatch = remaining.slice(styledIdx).match(/^\x1b\[[0-9;]*m/);
-      if (ansiMatch) {
-        styledIdx += ansiMatch[0].length;
-        continue;
-      }
-      if (remaining[styledIdx] === " " || remaining[styledIdx] === "\t") {
-        styledIdx++;
-      } else {
-        break;
-      }
-    }
-
-    result.push(remaining.slice(0, styledIdx).trimEnd());
-    remaining = remaining.slice(styledIdx);
-  }
-
-  if (remaining.trim()) {
-    result.push(remaining.trimEnd());
-  }
-
-  return result.length > 0 ? result : [styledText];
-}
-
-/**
- * Strip ANSI escape codes from a string.
- */
-function stripAnsi(text: string): string {
-  // biome-ignore lint: regex for ANSI codes
-  return text.replace(/\x1b\[[0-9;]*m/g, "");
-}
